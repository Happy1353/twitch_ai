<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VRM Avatar - Twitch AI Girl</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        
        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #status.talking {
            background: rgba(0, 255, 0, 0.3);
            border: 2px solid #00ff00;
        }
        
        .indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #666;
        }
        
        .indicator.active {
            background: #00ff00;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="status">
        <div class="indicator" id="indicator"></div>
        <span id="statusText">Загрузка...</span>
    </div>
    <div id="loading">Загрузка VRM модели...</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/",
            "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3/lib/three-vrm.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';

        // Scene setup
        const canvas = document.getElementById('canvas');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x667eea);
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1.3, 2);
        
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        
        const controls = new OrbitControls(camera, canvas);
        controls.target.set(0, 1.3, 0);
        controls.update();
        
        // Lighting
        const light = new THREE.DirectionalLight(0xffffff, 2);
        light.position.set(1, 1, 1).normalize();
        scene.add(light);
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        
        // VRM model
        let vrm = null;
        let isTalking = false;
        let mouthAnimation = 0;
        
        // Animation state
        let idleAnimation = 0;
        let blinkTimer = 0;
        let nextBlinkTime = 3; // Blink every 3 seconds
        
        // Load VRM
        const loader = new GLTFLoader();
        loader.register((parser) => new VRMLoaderPlugin(parser));
        
        updateStatus('Загрузка VRM модели...', false);
        
        // Load VRM from HTTP server
        const vrmPath = '/assets/ai_girl.vrm';
        
        console.log('Попытка загрузки VRM из:', vrmPath);
        console.log('Полный URL:', window.location.origin + vrmPath);
        
        loader.load(
            vrmPath,
            (gltf) => {
                console.log('✓ VRM загружена успешно!');
                vrm = gltf.userData.vrm;
                
                // Add VRM to scene
                VRMUtils.rotateVRM0(vrm);
                scene.add(vrm.scene);
                
                document.getElementById('loading').style.display = 'none';
                updateStatus('Готов к работе', false);
                
                console.log('VRM модель загружена!', vrm);
                console.log('Доступные blendshapes:', vrm.expressionManager?.expressionMap || vrm.blendShapeProxy?.expressions);
            },
            (progress) => {
                const loaded = (progress.loaded / 1024 / 1024).toFixed(1);
                const total = (progress.total / 1024 / 1024).toFixed(1);
                const percent = (progress.loaded / progress.total) * 100;
                updateStatus(`Загрузка ${percent.toFixed(0)}% (${loaded}/${total} MB)`, false);
                console.log(`Прогресс: ${loaded}MB / ${total}MB`);
            },
            (error) => {
                console.error('❌ Ошибка загрузки VRM:', error);
                updateStatus('❌ Ошибка! Проверьте консоль (F12)', false);
                
                // Show detailed error
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(255,0,0,0.8);color:white;padding:20px;border-radius:10px;max-width:500px;';
                errorDiv.innerHTML = `
                    <h3>Ошибка загрузки VRM модели</h3>
                    <p>${error.message || error}</p>
                    <p><b>Откройте консоль (F12) для деталей</b></p>
                `;
                document.body.appendChild(errorDiv);
            }
        );
        
        // WebSocket connection
        let ws = null;
        
        function connectWebSocket() {
            ws = new WebSocket('ws://localhost:8765');
            
            ws.onopen = () => {
                console.log('WebSocket подключен');
                updateStatus('Подключено к серверу', false);
            };
            
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                
                if (data.action === 'start_talking') {
                    isTalking = true;
                    updateStatus('Говорит...', true);
                } else if (data.action === 'stop_talking') {
                    isTalking = false;
                    mouthAnimation = 0;
                    updateStatus('Слушает', false);
                    resetMouth();
                }
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket ошибка:', error);
            };
            
            ws.onclose = () => {
                console.log('WebSocket отключен, переподключение...');
                setTimeout(connectWebSocket, 2000);
            };
        }
        
        connectWebSocket();
        
        // Update status
        function updateStatus(text, talking) {
            document.getElementById('statusText').textContent = text;
            const indicator = document.getElementById('indicator');
            const status = document.getElementById('status');
            
            if (talking) {
                indicator.classList.add('active');
                status.classList.add('talking');
            } else {
                indicator.classList.remove('active');
                status.classList.remove('talking');
            }
        }
        
        // Animate mouth
        function animateMouth(delta) {
            if (!vrm || !isTalking) return;
            
            mouthAnimation += delta * 10;
            
            // Simple mouth animation using sine wave
            const mouthValue = Math.abs(Math.sin(mouthAnimation)) * 0.8;
            
            // Try different expression systems (VRM 0.x and 1.0)
            if (vrm.expressionManager) {
                // VRM 1.0
                vrm.expressionManager.setValue('aa', mouthValue); // Open mouth
                vrm.expressionManager.setValue('ih', mouthValue * 0.3);
            } else if (vrm.blendShapeProxy) {
                // VRM 0.x
                vrm.blendShapeProxy.setValue('a', mouthValue);
                vrm.blendShapeProxy.setValue('i', mouthValue * 0.3);
            }
        }
        
        // Idle animations - make model feel alive!
        function animateIdle(delta) {
            if (!vrm) return;
            
            idleAnimation += delta;
            
            // 1. Breathing animation (chest movement)
            const breathingCycle = Math.sin(idleAnimation * 1.5) * 0.02;
            if (vrm.humanoid) {
                const chest = vrm.humanoid.getNormalizedBoneNode('chest');
                if (chest) {
                    chest.rotation.x = breathingCycle;
                }
            }
            
            // 2. Subtle head movement (looking around)
            if (!isTalking && vrm.humanoid) {
                const head = vrm.humanoid.getNormalizedBoneNode('head');
                if (head) {
                    // Gentle head rotation
                    head.rotation.y = Math.sin(idleAnimation * 0.5) * 0.1;
                    head.rotation.x = Math.sin(idleAnimation * 0.3) * 0.05 - 0.05;
                }
            }
            
            // 3. Blinking
            blinkTimer += delta;
            if (blinkTimer >= nextBlinkTime) {
                blink();
                blinkTimer = 0;
                nextBlinkTime = 2 + Math.random() * 4; // Random interval 2-6 seconds
            }
            
            // 4. Subtle body sway
            if (vrm.scene) {
                vrm.scene.position.x = Math.sin(idleAnimation * 0.8) * 0.01;
                vrm.scene.position.y = Math.abs(Math.sin(idleAnimation * 1.5)) * 0.02;
            }
        }
        
        // Blinking animation
        function blink() {
            if (!vrm) return;
            
            let blinkValue = 0;
            const blinkSpeed = 0.15; // Fast blink
            
            // Close eyes
            const closeInterval = setInterval(() => {
                blinkValue += blinkSpeed;
                if (blinkValue >= 1) {
                    blinkValue = 1;
                    clearInterval(closeInterval);
                    
                    // Open eyes after brief pause
                    setTimeout(() => {
                        const openInterval = setInterval(() => {
                            blinkValue -= blinkSpeed;
                            if (blinkValue <= 0) {
                                blinkValue = 0;
                                clearInterval(openInterval);
                            }
                            setBlinkValue(blinkValue);
                        }, 16);
                    }, 50); // Brief pause with eyes closed
                }
                setBlinkValue(blinkValue);
            }, 16);
        }
        
        // Set blink expression value
        function setBlinkValue(value) {
            if (!vrm) return;
            
            if (vrm.expressionManager) {
                // VRM 1.0
                vrm.expressionManager.setValue('blink', value);
                vrm.expressionManager.setValue('blinkLeft', value);
                vrm.expressionManager.setValue('blinkRight', value);
            } else if (vrm.blendShapeProxy) {
                // VRM 0.x
                vrm.blendShapeProxy.setValue('blink', value);
                vrm.blendShapeProxy.setValue('blink_l', value);
                vrm.blendShapeProxy.setValue('blink_r', value);
            }
        }
        
        function resetMouth() {
            if (!vrm) return;
            
            if (vrm.expressionManager) {
                vrm.expressionManager.setValue('aa', 0);
                vrm.expressionManager.setValue('ih', 0);
            } else if (vrm.blendShapeProxy) {
                vrm.blendShapeProxy.setValue('a', 0);
                vrm.blendShapeProxy.setValue('i', 0);
            }
        }
        
        // Animation loop
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            // Update VRM
            if (vrm) {
                vrm.update(delta);
                animateMouth(delta);
                animateIdle(delta); // Add idle animations!
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        animate();
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>

