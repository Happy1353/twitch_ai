<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VRM Avatar - Twitch AI Girl</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        
        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #status.talking {
            background: rgba(0, 255, 0, 0.3);
            border: 2px solid #00ff00;
        }
        
        .indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #666;
        }
        
        .indicator.active {
            background: #00ff00;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="status">
        <div class="indicator" id="indicator"></div>
        <span id="statusText">–ó–∞–≥—Ä—É–∑–∫–∞...</span>
    </div>
    <div id="loading">–ó–∞–≥—Ä—É–∑–∫–∞ VRM –º–æ–¥–µ–ª–∏...</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/",
            "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3/lib/three-vrm.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';

        // Scene setup
        const canvas = document.getElementById('canvas');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x667eea);
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1.3, 2);
        
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        
        const controls = new OrbitControls(camera, canvas);
        controls.target.set(0, 1.3, 0);
        controls.update();
        
        // Lighting
        const light = new THREE.DirectionalLight(0xffffff, 2);
        light.position.set(1, 1, 1).normalize();
        scene.add(light);
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        
        // VRM model
        let vrm = null;
        let isTalking = false;
        let mouthAnimation = 0;
        
        // Animation state
        let idleAnimation = 0;
        let blinkTimer = 0;
        let nextBlinkTime = 3; // Blink every 3 seconds
        let handAnimationOffset = Math.random() * Math.PI * 2; // Random start for hands
        
        // Load VRM
        const loader = new GLTFLoader();
        loader.register((parser) => new VRMLoaderPlugin(parser));
        
        updateStatus('–ó–∞–≥—Ä—É–∑–∫–∞ VRM –º–æ–¥–µ–ª–∏...', false);
        
        // Load VRM from HTTP server
        const vrmPath = '/assets/ai_girl.vrm';
        
        console.log('–ü–æ–ø—ã—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ VRM –∏–∑:', vrmPath);
        console.log('–ü–æ–ª–Ω—ã–π URL:', window.location.origin + vrmPath);
        
        loader.load(
            vrmPath,
            (gltf) => {
                console.log('‚úì VRM –∑–∞–≥—Ä—É–∂–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ!');
                vrm = gltf.userData.vrm;
                
                // Add VRM to scene
                VRMUtils.rotateVRM0(vrm);
                scene.add(vrm.scene);
                
                // Set initial natural pose for arms
                setNaturalArmPose();
                
                document.getElementById('loading').style.display = 'none';
                updateStatus('–ì–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ', false);
                
                console.log('VRM –º–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞!', vrm);
                console.log('–î–æ—Å—Ç—É–ø–Ω—ã–µ blendshapes:', vrm.expressionManager?.expressionMap || vrm.blendShapeProxy?.expressions);
            },
            (progress) => {
                const loaded = (progress.loaded / 1024 / 1024).toFixed(1);
                const total = (progress.total / 1024 / 1024).toFixed(1);
                const percent = (progress.loaded / progress.total) * 100;
                updateStatus(`–ó–∞–≥—Ä—É–∑–∫–∞ ${percent.toFixed(0)}% (${loaded}/${total} MB)`, false);
                console.log(`–ü—Ä–æ–≥—Ä–µ—Å—Å: ${loaded}MB / ${total}MB`);
            },
            (error) => {
                console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ VRM:', error);
                updateStatus('‚ùå –û—à–∏–±–∫–∞! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–Ω—Å–æ–ª—å (F12)', false);
                
                // Show detailed error
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(255,0,0,0.8);color:white;padding:20px;border-radius:10px;max-width:500px;';
                errorDiv.innerHTML = `
                    <h3>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ VRM –º–æ–¥–µ–ª–∏</h3>
                    <p>${error.message || error}</p>
                    <p><b>–û—Ç–∫—Ä–æ–π—Ç–µ –∫–æ–Ω—Å–æ–ª—å (F12) –¥–ª—è –¥–µ—Ç–∞–ª–µ–π</b></p>
                `;
                document.body.appendChild(errorDiv);
            }
        );
        
        // Audio playback
        let currentAudio = null;
        
        function playAudioFromBase64(base64Data) {
            try {
                // Convert base64 to blob
                const binaryString = atob(base64Data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                const blob = new Blob([bytes], { type: 'audio/mpeg' });
                const audioUrl = URL.createObjectURL(blob);
                
                // Create and play audio
                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio = null;
                }
                
                currentAudio = new Audio(audioUrl);
                currentAudio.volume = 1.0;
                
                currentAudio.onended = () => {
                    URL.revokeObjectURL(audioUrl);
                    currentAudio = null;
                };
                
                currentAudio.play()
                    .then(() => {
                        console.log('‚úì –ê—É–¥–∏–æ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç—Å—è');
                    })
                    .catch(err => {
                        console.error('‚ùå –û—à–∏–±–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è:', err);
                    });
                
            } catch (error) {
                console.error('‚ùå –û—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è –∞—É–¥–∏–æ:', error);
            }
        }
        
        // WebSocket connection
        let ws = null;
        
        function connectWebSocket() {
            ws = new WebSocket('ws://localhost:8765');
            
            ws.onopen = () => {
                console.log('WebSocket –ø–æ–¥–∫–ª—é—á–µ–Ω');
                updateStatus('–ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ —Å–µ—Ä–≤–µ—Ä—É', false);
            };
            
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                
                if (data.action === 'start_talking') {
                    isTalking = true;
                    updateStatus('–ì–æ–≤–æ—Ä–∏—Ç...', true);
                } else if (data.action === 'stop_talking') {
                    isTalking = false;
                    mouthAnimation = 0;
                    updateStatus('–°–ª—É—à–∞–µ—Ç', false);
                    resetMouth();
                } else if (data.action === 'play_audio') {
                    // Play audio received from server
                    console.log('üéµ –ü–æ–ª—É—á–µ–Ω–æ –∞—É–¥–∏–æ, –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ...');
                    playAudioFromBase64(data.audio);
                }
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket –æ—à–∏–±–∫–∞:', error);
            };
            
            ws.onclose = () => {
                console.log('WebSocket –æ—Ç–∫–ª—é—á–µ–Ω, –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...');
                setTimeout(connectWebSocket, 2000);
            };
        }
        
        connectWebSocket();
        
        // Update status
        function updateStatus(text, talking) {
            document.getElementById('statusText').textContent = text;
            const indicator = document.getElementById('indicator');
            const status = document.getElementById('status');
            
            if (talking) {
                indicator.classList.add('active');
                status.classList.add('talking');
            } else {
                indicator.classList.remove('active');
                status.classList.remove('talking');
            }
        }
        
        // Animate mouth
        function animateMouth(delta) {
            if (!vrm || !isTalking) return;
            
            mouthAnimation += delta * 10;
            
            // Simple mouth animation using sine wave
            const mouthValue = Math.abs(Math.sin(mouthAnimation)) * 0.8;
            
            // Try different expression systems (VRM 0.x and 1.0)
            if (vrm.expressionManager) {
                // VRM 1.0
                vrm.expressionManager.setValue('aa', mouthValue); // Open mouth
                vrm.expressionManager.setValue('ih', mouthValue * 0.3);
            } else if (vrm.blendShapeProxy) {
                // VRM 0.x
                vrm.blendShapeProxy.setValue('a', mouthValue);
                vrm.blendShapeProxy.setValue('i', mouthValue * 0.3);
            }
        }
        
        // Set natural arm pose
        function setNaturalArmPose() {
            if (!vrm || !vrm.humanoid) return;

            const leftUpperArm = vrm.humanoid.getNormalizedBoneNode('leftUpperArm');
            const rightUpperArm = vrm.humanoid.getNormalizedBoneNode('rightUpperArm');
            const leftLowerArm = vrm.humanoid.getNormalizedBoneNode('leftLowerArm');
            const rightLowerArm = vrm.humanoid.getNormalizedBoneNode('rightLowerArm');
            const leftHand = vrm.humanoid.getNormalizedBoneNode('leftHand');
            const rightHand = vrm.humanoid.getNormalizedBoneNode('rightHand');

            if (leftUpperArm && rightUpperArm) {
                // –û–ø—É—Å–∫–∞–µ–º —Ä—É–∫–∏ –ø—Ä–∏–º–µ—Ä–Ω–æ –Ω–∞ 60 –≥—Ä–∞–¥—É—Å–æ–≤ –≤–Ω–∏–∑
                leftUpperArm.rotation.x += THREE.MathUtils.degToRad(-60);
                rightUpperArm.rotation.x += THREE.MathUtils.degToRad(-60);
            }

            if (leftLowerArm && rightLowerArm) {
                // –ù–µ–º–Ω–æ–≥–æ —Å–≥–∏–±–∞–µ–º –ª–æ–∫—Ç–∏
                leftLowerArm.rotation.x += THREE.MathUtils.degToRad(10);
                rightLowerArm.rotation.x += THREE.MathUtils.degToRad(10);
            }

            if (leftHand && rightHand) {
                // –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –ª–∞–¥–æ–Ω–∏ –Ω–µ–º–Ω–æ–≥–æ –≤–Ω—É—Ç—Ä—å
                leftHand.rotation.z += THREE.MathUtils.degToRad(10);
                rightHand.rotation.z += THREE.MathUtils.degToRad(-10);
            }
        }

        
        // Animate arms naturally
        function animateArms(delta) {
            if (!vrm || !vrm.humanoid) return;
            
            // Subtle arm movements
            const leftUpperArm = vrm.humanoid.getNormalizedBoneNode('leftUpperArm');
            const rightUpperArm = vrm.humanoid.getNormalizedBoneNode('rightUpperArm');
            
            if (isTalking) {
                // Gentle gestures when talking (arms stay mostly down)
                if (leftUpperArm) {
                    leftUpperArm.rotation.z = Math.sin(idleAnimation * 2 + handAnimationOffset) * 0.08;
                    leftUpperArm.rotation.x = Math.sin(idleAnimation * 1.5) * 0.05;
                }
                if (rightUpperArm) {
                    rightUpperArm.rotation.z = Math.sin(idleAnimation * 2.3 + handAnimationOffset + Math.PI) * 0.08;
                    rightUpperArm.rotation.x = Math.sin(idleAnimation * 1.7) * 0.05;
                }
            } else {
                // Very minimal idle movements (arms hanging straight)
                if (leftUpperArm) {
                    leftUpperArm.rotation.z = Math.sin(idleAnimation * 0.8 + handAnimationOffset) * 0.02;
                    leftUpperArm.rotation.x = Math.sin(idleAnimation * 0.6) * 0.01;
                }
                if (rightUpperArm) {
                    rightUpperArm.rotation.z = Math.sin(idleAnimation * 0.9 + handAnimationOffset + Math.PI) * 0.02;
                    rightUpperArm.rotation.x = Math.sin(idleAnimation * 0.7) * 0.01;
                }
            }
        }
        
        // Idle animations - make model feel alive!
        function animateIdle(delta) {
            if (!vrm) return;
            
            idleAnimation += delta;
            
            // 1. Breathing animation (chest movement)
            const breathingCycle = Math.sin(idleAnimation * 1.5) * 0.02;
            if (vrm.humanoid) {
                const chest = vrm.humanoid.getNormalizedBoneNode('chest');
                if (chest) {
                    chest.rotation.x = breathingCycle;
                }
            }
            
            // 2. Subtle head movement (looking around)
            if (!isTalking && vrm.humanoid) {
                const head = vrm.humanoid.getNormalizedBoneNode('head');
                if (head) {
                    // Gentle head rotation
                    head.rotation.y = Math.sin(idleAnimation * 0.5) * 0.1;
                    head.rotation.x = Math.sin(idleAnimation * 0.3) * 0.05 - 0.05;
                }
            }
            
            // 3. Blinking
            blinkTimer += delta;
            if (blinkTimer >= nextBlinkTime) {
                blink();
                blinkTimer = 0;
                nextBlinkTime = 2 + Math.random() * 4; // Random interval 2-6 seconds
            }
            
            // 4. Subtle body sway
            if (vrm.scene) {
                vrm.scene.position.x = Math.sin(idleAnimation * 0.8) * 0.01;
                vrm.scene.position.y = Math.abs(Math.sin(idleAnimation * 1.5)) * 0.02;
            }
            
            // 5. Arm animations
            animateArms(delta);
        }
        
        // Blinking animation
        function blink() {
            if (!vrm) return;
            
            let blinkValue = 0;
            const blinkSpeed = 0.15; // Fast blink
            
            // Close eyes
            const closeInterval = setInterval(() => {
                blinkValue += blinkSpeed;
                if (blinkValue >= 1) {
                    blinkValue = 1;
                    clearInterval(closeInterval);
                    
                    // Open eyes after brief pause
                    setTimeout(() => {
                        const openInterval = setInterval(() => {
                            blinkValue -= blinkSpeed;
                            if (blinkValue <= 0) {
                                blinkValue = 0;
                                clearInterval(openInterval);
                            }
                            setBlinkValue(blinkValue);
                        }, 16);
                    }, 50); // Brief pause with eyes closed
                }
                setBlinkValue(blinkValue);
            }, 16);
        }
        
        // Set blink expression value
        function setBlinkValue(value) {
            if (!vrm) return;
            
            if (vrm.expressionManager) {
                // VRM 1.0
                vrm.expressionManager.setValue('blink', value);
                vrm.expressionManager.setValue('blinkLeft', value);
                vrm.expressionManager.setValue('blinkRight', value);
            } else if (vrm.blendShapeProxy) {
                // VRM 0.x
                vrm.blendShapeProxy.setValue('blink', value);
                vrm.blendShapeProxy.setValue('blink_l', value);
                vrm.blendShapeProxy.setValue('blink_r', value);
            }
        }
        
        function resetMouth() {
            if (!vrm) return;
            
            if (vrm.expressionManager) {
                vrm.expressionManager.setValue('aa', 0);
                vrm.expressionManager.setValue('ih', 0);
            } else if (vrm.blendShapeProxy) {
                vrm.blendShapeProxy.setValue('a', 0);
                vrm.blendShapeProxy.setValue('i', 0);
            }
        }
        
        // Animation loop
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            // Update VRM
            if (vrm) {
                vrm.update(delta);
                animateMouth(delta);
                animateIdle(delta); // Add idle animations!
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        animate();
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>

