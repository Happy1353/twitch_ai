<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VRM Avatar - Twitch AI Girl</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="loading">–ó–∞–≥—Ä—É–∑–∫–∞ VRM –º–æ–¥–µ–ª–∏...</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/",
            "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3/lib/three-vrm.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';

        // Scene setup
        const canvas = document.getElementById('canvas');
        const scene = new THREE.Scene();
        
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1.2, 2); // POV like webcam on desk
        
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        const controls = new OrbitControls(camera, canvas);
        controls.target.set(0, 1.2, 0);
        controls.minDistance = 1.0;
        controls.maxDistance = 4.0;
        controls.maxPolarAngle = Math.PI / 1.8;
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.update();
        
        // VRM model
        let vrm = null;
        let isTalking = false;
        let mouthAnimation = 0;
        
        // Animation state
        let idleAnimation = 0;
        let blinkTimer = 0;
        let nextBlinkTime = 3; // Blink every 3 seconds
        let handAnimationOffset = Math.random() * Math.PI * 2; // Random start for hands
        
        // Scene loaded flag
        let roomLoaded = false;
        
        // Load bedroom scene first
        console.log('üè† –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–º–Ω–∞—Ç—ã...');
        const gltfLoader = new GLTFLoader();
        
        gltfLoader.load(
            '/assets/bedroom_scene.glb',
            (gltf) => {
                console.log('‚úì –ö–æ–º–Ω–∞—Ç–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞!');
                
                // Add room to scene with proper scale
                gltf.scene.scale.set(0.015, 0.015, 0.015); // Reduce room size
                gltf.scene.rotation.y =  - Math.PI / 2; // Rotate 90 degrees
                
                scene.add(gltf.scene);
                
                // Enable shadows for all meshes
                gltf.scene.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        
                        // Ensure materials render properly
                        if (child.material) {
                            child.material.needsUpdate = true;
                        }
                    }
                });
                
                // Setup lighting after room is loaded
                setupLighting();
                
                roomLoaded = true;
                
                // Now load VRM
                loadVRM();
            },
            (progress) => {
                const percent = (progress.loaded / progress.total * 100).toFixed(0);
                console.log(`–ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–º–Ω–∞—Ç—ã: ${percent}%`);
                document.getElementById('loading').textContent = `–ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–º–Ω–∞—Ç—ã ${percent}%...`;
            },
            (error) => {
                console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–æ–º–Ω–∞—Ç—ã:', error);
                // Try to load VRM anyway
                loadVRM();
            }
        );
        
        // Setup realistic lighting
        function setupLighting() {
            // Ambient light (soft fill)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            // Main directional light (window/sun)
            const sunLight = new THREE.DirectionalLight(0xfff8f0, 1.5);
            sunLight.position.set(5, 6, 3);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 20;
            sunLight.shadow.camera.left = -5;
            sunLight.shadow.camera.right = 5;
            sunLight.shadow.camera.top = 5;
            sunLight.shadow.camera.bottom = -5;
            scene.add(sunLight);
            
            // Fill light (opposite side)
            const fillLight = new THREE.DirectionalLight(0xb8d4ff, 0.5);
            fillLight.position.set(-3, 3, 2);
            scene.add(fillLight);
            
            // Warm point light (for character)
            const charLight = new THREE.PointLight(0xffeedd, 1.0, 5);
            charLight.position.set(0, 1.5, 1);
            scene.add(charLight);
            
            console.log('‚úì –û—Å–≤–µ—â–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ');
        }
        
        // Load VRM
        const vrmLoader = new GLTFLoader();
        vrmLoader.register((parser) => new VRMLoaderPlugin(parser));
        
        function loadVRM() {
        
            console.log('üë© –ó–∞–≥—Ä—É–∑–∫–∞ VRM –º–æ–¥–µ–ª–∏...');
            document.getElementById('loading').textContent = '–ó–∞–≥—Ä—É–∑–∫–∞ –¥–µ–≤—É—à–∫–∏...';
            
            const vrmPath = '/assets/ai_girl.vrm';
            
            vrmLoader.load(
                vrmPath,
            (gltf) => {
                console.log('‚úì VRM –∑–∞–≥—Ä—É–∂–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ!');
                vrm = gltf.userData.vrm;
                
                // Add VRM to scene
                VRMUtils.rotateVRM0(vrm);
                scene.add(vrm.scene);
                
                // Set initial natural pose for arms
                setNaturalArmPose();
                
                // Position VRM in the scene
                vrm.scene.position.set(0, 0, 0);
                vrm.scene.rotation.y = 0; // Face forward
                
                // Scale VRM if needed (uncomment if still too small)
                // vrm.scene.scale.set(1.2, 1.2, 1.2);
                
                document.getElementById('loading').style.display = 'none';
                
                console.log('VRM –º–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞!', vrm);
                console.log('–î–æ—Å—Ç—É–ø–Ω—ã–µ blendshapes:', vrm.expressionManager?.expressionMap || vrm.blendShapeProxy?.expressions);
            },
                (progress) => {
                    const percent = (progress.loaded / progress.total * 100).toFixed(0);
                    console.log(`–ó–∞–≥—Ä—É–∑–∫–∞ VRM: ${percent}%`);
                },
                (error) => {
                    console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ VRM:', error);
                    document.getElementById('loading').textContent = '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ VRM!';
                }
            );
        }
        
        // Audio playback
        let currentAudio = null;
        
        function playAudioFromBase64(base64Data) {
            try {
                // Convert base64 to blob
                const binaryString = atob(base64Data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                const blob = new Blob([bytes], { type: 'audio/mpeg' });
                const audioUrl = URL.createObjectURL(blob);
                
                // Create and play audio
                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio = null;
                }
                
                currentAudio = new Audio(audioUrl);
                currentAudio.volume = 1.0;
                
                currentAudio.onended = () => {
                    URL.revokeObjectURL(audioUrl);
                    currentAudio = null;
                };
                
                currentAudio.play()
                    .then(() => {
                        console.log('‚úì –ê—É–¥–∏–æ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç—Å—è');
                    })
                    .catch(err => {
                        console.error('‚ùå –û—à–∏–±–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è:', err);
                    });
                
            } catch (error) {
                console.error('‚ùå –û—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è –∞—É–¥–∏–æ:', error);
            }
        }
        
        // WebSocket connection
        let ws = null;
        
        function connectWebSocket() {
            ws = new WebSocket('ws://localhost:8765');
            
            ws.onopen = () => {
                console.log('WebSocket –ø–æ–¥–∫–ª—é—á–µ–Ω');
            };
            
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                
                if (data.action === 'start_talking') {
                    isTalking = true;
                    console.log('üëÑ –ù–∞—á–∞–ª–æ —Ä–µ—á–∏');
                } else if (data.action === 'stop_talking') {
                    isTalking = false;
                    mouthAnimation = 0;
                    resetMouth();
                    console.log('ü§ê –ö–æ–Ω–µ—Ü —Ä–µ—á–∏');
                } else if (data.action === 'play_audio') {
                    // Play audio received from server
                    console.log('üéµ –ü–æ–ª—É—á–µ–Ω–æ –∞—É–¥–∏–æ, –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ...');
                    playAudioFromBase64(data.audio);
                }
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket –æ—à–∏–±–∫–∞:', error);
            };
            
            ws.onclose = () => {
                console.log('WebSocket –æ—Ç–∫–ª—é—á–µ–Ω, –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...');
                setTimeout(connectWebSocket, 2000);
            };
        }
        
        connectWebSocket();
        
        // Animate mouth
        function animateMouth(delta) {
            if (!vrm || !isTalking) return;
            
            mouthAnimation += delta * 10;
            
            // Simple mouth animation using sine wave
            const mouthValue = Math.abs(Math.sin(mouthAnimation)) * 0.8;
            
            // Try different expression systems (VRM 0.x and 1.0)
            if (vrm.expressionManager) {
                // VRM 1.0
                vrm.expressionManager.setValue('aa', mouthValue); // Open mouth
                vrm.expressionManager.setValue('ih', mouthValue * 0.3);
            } else if (vrm.blendShapeProxy) {
                // VRM 0.x
                vrm.blendShapeProxy.setValue('a', mouthValue);
                vrm.blendShapeProxy.setValue('i', mouthValue * 0.3);
            }
        }
        
        // Set natural arm pose
        function setNaturalArmPose() {
            if (!vrm || !vrm.humanoid) return;

            const leftUpperArm = vrm.humanoid.getNormalizedBoneNode('leftUpperArm');
            const rightUpperArm = vrm.humanoid.getNormalizedBoneNode('rightUpperArm');
            const leftLowerArm = vrm.humanoid.getNormalizedBoneNode('leftLowerArm');
            const rightLowerArm = vrm.humanoid.getNormalizedBoneNode('rightLowerArm');
            const leftHand = vrm.humanoid.getNormalizedBoneNode('leftHand');
            const rightHand = vrm.humanoid.getNormalizedBoneNode('rightHand');

            if (leftUpperArm && rightUpperArm) {
                // –û–ø—É—Å–∫–∞–µ–º —Ä—É–∫–∏ –ø—Ä–∏–º–µ—Ä–Ω–æ –Ω–∞ 60 –≥—Ä–∞–¥—É—Å–æ–≤ –≤–Ω–∏–∑
                leftUpperArm.rotation.x += THREE.MathUtils.degToRad(-60);
                rightUpperArm.rotation.x += THREE.MathUtils.degToRad(-60);
            }

            if (leftLowerArm && rightLowerArm) {
                // –ù–µ–º–Ω–æ–≥–æ —Å–≥–∏–±–∞–µ–º –ª–æ–∫—Ç–∏
                leftLowerArm.rotation.x += THREE.MathUtils.degToRad(10);
                rightLowerArm.rotation.x += THREE.MathUtils.degToRad(10);
            }

            if (leftHand && rightHand) {
                // –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –ª–∞–¥–æ–Ω–∏ –Ω–µ–º–Ω–æ–≥–æ –≤–Ω—É—Ç—Ä—å
                leftHand.rotation.z += THREE.MathUtils.degToRad(10);
                rightHand.rotation.z += THREE.MathUtils.degToRad(-10);
            }
        }

        
        // Animate arms naturally
        function animateArms(delta) {
            if (!vrm || !vrm.humanoid) return;
            
            // Subtle arm movements
            const leftUpperArm = vrm.humanoid.getNormalizedBoneNode('leftUpperArm');
            const rightUpperArm = vrm.humanoid.getNormalizedBoneNode('rightUpperArm');
            
            if (isTalking) {
                // Gentle gestures when talking (arms stay mostly down)
                if (leftUpperArm) {
                    leftUpperArm.rotation.z = Math.sin(idleAnimation * 2 + handAnimationOffset) * 0.08;
                    leftUpperArm.rotation.x = Math.sin(idleAnimation * 1.5) * 0.05;
                }
                if (rightUpperArm) {
                    rightUpperArm.rotation.z = Math.sin(idleAnimation * 2.3 + handAnimationOffset + Math.PI) * 0.08;
                    rightUpperArm.rotation.x = Math.sin(idleAnimation * 1.7) * 0.05;
                }
            } else {
                // Very minimal idle movements (arms hanging straight)
                if (leftUpperArm) {
                    leftUpperArm.rotation.z = Math.sin(idleAnimation * 0.8 + handAnimationOffset) * 0.02;
                    leftUpperArm.rotation.x = Math.sin(idleAnimation * 0.6) * 0.01;
                }
                if (rightUpperArm) {
                    rightUpperArm.rotation.z = Math.sin(idleAnimation * 0.9 + handAnimationOffset + Math.PI) * 0.02;
                    rightUpperArm.rotation.x = Math.sin(idleAnimation * 0.7) * 0.01;
                }
            }
        }
        
        // Idle animations - make model feel alive!
        function animateIdle(delta) {
            if (!vrm) return;
            
            idleAnimation += delta;
            
            // 1. Breathing animation (chest movement)
            const breathingCycle = Math.sin(idleAnimation * 1.5) * 0.02;
            if (vrm.humanoid) {
                const chest = vrm.humanoid.getNormalizedBoneNode('chest');
                if (chest) {
                    chest.rotation.x = breathingCycle;
                }
            }
            
            // 2. Subtle head movement (looking around)
            if (!isTalking && vrm.humanoid) {
                const head = vrm.humanoid.getNormalizedBoneNode('head');
                if (head) {
                    // Gentle head rotation
                    head.rotation.y = Math.sin(idleAnimation * 0.5) * 0.1;
                    head.rotation.x = Math.sin(idleAnimation * 0.3) * 0.05 - 0.05;
                }
            }
            
            // 3. Blinking
            blinkTimer += delta;
            if (blinkTimer >= nextBlinkTime) {
                blink();
                blinkTimer = 0;
                nextBlinkTime = 2 + Math.random() * 4; // Random interval 2-6 seconds
            }
            
            // 4. Subtle body sway
            if (vrm.scene) {
                vrm.scene.position.x = Math.sin(idleAnimation * 0.8) * 0.01;
                vrm.scene.position.y = Math.abs(Math.sin(idleAnimation * 1.5)) * 0.02;
            }
            
            // 5. Arm animations
            animateArms(delta);
        }
        
        // Blinking animation
        function blink() {
            if (!vrm) return;
            
            let blinkValue = 0;
            const blinkSpeed = 0.15; // Fast blink
            
            // Close eyes
            const closeInterval = setInterval(() => {
                blinkValue += blinkSpeed;
                if (blinkValue >= 1) {
                    blinkValue = 1;
                    clearInterval(closeInterval);
                    
                    // Open eyes after brief pause
                    setTimeout(() => {
                        const openInterval = setInterval(() => {
                            blinkValue -= blinkSpeed;
                            if (blinkValue <= 0) {
                                blinkValue = 0;
                                clearInterval(openInterval);
                            }
                            setBlinkValue(blinkValue);
                        }, 16);
                    }, 50); // Brief pause with eyes closed
                }
                setBlinkValue(blinkValue);
            }, 16);
        }
        
        // Set blink expression value
        function setBlinkValue(value) {
            if (!vrm) return;
            
            if (vrm.expressionManager) {
                // VRM 1.0
                vrm.expressionManager.setValue('blink', value);
                vrm.expressionManager.setValue('blinkLeft', value);
                vrm.expressionManager.setValue('blinkRight', value);
            } else if (vrm.blendShapeProxy) {
                // VRM 0.x
                vrm.blendShapeProxy.setValue('blink', value);
                vrm.blendShapeProxy.setValue('blink_l', value);
                vrm.blendShapeProxy.setValue('blink_r', value);
            }
        }
        
        function resetMouth() {
            if (!vrm) return;
            
            if (vrm.expressionManager) {
                vrm.expressionManager.setValue('aa', 0);
                vrm.expressionManager.setValue('ih', 0);
            } else if (vrm.blendShapeProxy) {
                vrm.blendShapeProxy.setValue('a', 0);
                vrm.blendShapeProxy.setValue('i', 0);
            }
        }
        
        // Animation loop
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            // Update VRM
            if (vrm) {
                vrm.update(delta);
                animateMouth(delta);
                animateIdle(delta); // Add idle animations!
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        animate();
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>

